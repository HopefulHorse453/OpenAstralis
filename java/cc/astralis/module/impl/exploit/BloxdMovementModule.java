package cc.astralis.module.impl.exploit;

import cc.astralis.event.EventTarget;
import cc.astralis.event.events.impl.game.MoveEvent;
import cc.astralis.event.events.impl.network.PacketEvent;
import cc.astralis.event.types.EventModes;
import cc.astralis.module.Category;
import cc.astralis.module.Module;
import cc.astralis.util.math.NoaPhysicsUtil;
import io.netty.buffer.ByteBuf;
import net.minecraft.client.player.LocalPlayer;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.network.protocol.common.ClientboundCustomPayloadPacket;
import net.minecraft.network.protocol.game.ClientboundSetEntityMotionPacket;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.effect.MobEffects;
import net.minecraft.world.phys.Vec2;
import org.joml.Vector3d;

public class BloxdMovementModule extends Module {

    private final NoaPhysicsUtil physics = new NoaPhysicsUtil();
    private double jumpCount = 0.0;
    private long jumpCooldown = System.currentTimeMillis();

    public BloxdMovementModule() {
        super(Category.EXPLOIT);
    }

    @EventTarget
    public void onMove(MoveEvent event) {
        LocalPlayer player = mc.player;
        if (player == null || mc.level == null) return;

        if (player.onGround() && physics.velocityVector.y < 0.0) {
            physics.velocityVector.set(0.0, 0.0, 0.0);
        }

        if (event.getY() == 0.42f) {
            jumpCount = Math.min(jumpCount + 1.0, 3.0);
            physics.impulseVector.add(0.0, 8.0, 0.0);
        }

        jumpCount = (player.onGround() && player.tickCount > 5) ? 0.0 : jumpCount;

        double speed = jumpCooldown > System.currentTimeMillis() ? 1.0
                : player.isUsingItem() ? 0.06
                : 0.26 + 0.025 * jumpCount;

        if (player.hasEffect(MobEffects.SPEED)) {
            int amplifier = player.getEffect(MobEffects.SPEED).getAmplifier();
            speed += (amplifier == 0 ? 0.14 : 0.28);
        }

        Vector3d moveDir = getMoveDirection(speed);
        physics.gravityMul = 2.0;

        Vector3d motion = physics.getMotionForTick();
        event.setX(moveDir.x);
        event.setY(motion.y * 0.03333333333333333);
        event.setZ(moveDir.z);
    }

    @EventTarget
    public void onPacket(PacketEvent event) {
        if (event.getEventMode() == EventModes.RECEIVE && event.getPacket() instanceof ClientboundSetEntityMotionPacket packet) {
            if (packet.getId() == mc.player.getId()) {
                jumpCooldown = System.currentTimeMillis() + 1300L;
            }
        }

        if (event.getPacket() instanceof ClientboundCustomPayloadPacket packet) {
            ResourceLocation id = packet.type().id();
            if (id.getNamespace().equals("bloxd") && id.getPath().equals("resyncphysics")) {
                FriendlyByteBuf buf = new FriendlyByteBuf((ByteBuf) packet.payload());
                jumpCount = 0.0;
                physics.impulseVector.set(0.0, 0.0, 0.0);
                physics.forceVector.set(0.0, 0.0, 0.0);
                physics.velocityVector.set(buf.readFloat(), buf.readFloat(), buf.readFloat());
            }
        }
    }

    private Vector3d getMoveDirection(double speed) {
        Vec2 movement = mc.player.input.getMoveVector();

        float forward = movement.y;
        float strafe = movement.x;
        float yaw = mc.player.getYRot();

        if (forward == 0.0f && strafe == 0.0f) return new Vector3d(0.0, 0.0, 0.0);

        if (forward != 0.0f) {
            if (strafe > 0.0f) yaw += (forward > 0.0f ? -45 : 45);
            else if (strafe < 0.0f) yaw += (forward > 0.0f ? 45 : -45);
            strafe = 0.0f;
            forward = forward > 0.0f ? 1.0f : -1.0f;
        }

        double sin = Math.sin(Math.toRadians(yaw + 90.0f));
        double cos = Math.cos(Math.toRadians(yaw + 90.0f));
        return new Vector3d(forward * speed * cos + strafe * speed * sin, 0.0, forward * speed * sin - strafe * speed * cos);
    }
}
